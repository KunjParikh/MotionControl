# -*- coding: utf-8 -*-
"""Motion_control.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1pl4pheCd3i0qNX2JbFmEFAyAH0u51mrL
"""
"""
!apt - get
install
texlive
texlive - xetex
texlive - latex - extra
pandoc
!pip
install
pypandoc

from google.colab import drive

drive.mount('/content/drive')

!cp
'drive/My Drive/SJSU/Final Project/Code/Motion_control.ipynb'. /

!jupyter
nbconvert - -to
PDF
"Motion_control.ipynb"

!cp
Motion_control.pdf
drive /
"""
import matplotlib
import matplotlib.pyplot as plt
import numpy as np
from math import pi, sqrt, cos, sin, atan2, log

# f = lambda x, y: (x**2) + 3*(y**2) + (4*y) - x - (2*x*y)- 16
# dz_f = lambda x, y: [(2*x-1-2*y)/sqrt((x**2)+3*(y**2)+(4*y)-x-(2*x*y)),
#                    (6*y-4-2*x)/sqrt((x**2)+3*(y**2)+(4*y)-x-(2*x*y))]

K1 = 10
K2 = 6000
K3 = 20
K4 = 40
mu = 30
mu_f = 10
dt = 0.01
step = 10000

z_desired = 4

r_c = np.array([-2, -6])
z_c = f(r_c[0], r_c[1])

r = np.array(
    [r_c + [1, 0],
     r_c + [-1, 0],
     r_c + [0, -1],
     r_c + [0, 1]])

r_plot = [r]

phi = np.array(
    [[1 / 2, -1 / sqrt(2), 0, -1 / 2],
     [1 / 2, 1 / sqrt(2), 0, -1 / 2],
     [0, 0, 1 / sqrt(2), 1 / 2],
     [0, 0, -1 / sqrt(2), 1 / 2]
     ])

phi_inv = np.linalg.inv(phi)

# Jacobi vectors
numSensors = 4
q = phi @ r
dq = np.zeros((numSensors, 2))
u_r = np.zeros((numSensors, 2))
vel_q = np.zeros((numSensors, 2))


def kalmanFilter(z_c, dz, r, z_r, r_c, r_c_old, p, hessian, numSensors):
    s = np.array([z_c, *dz])  # 3x1
    m = 0.001 * np.identity(3)  # 3x1
    R = 0.001 * np.identity(numSensors)  # 4x4
    u = 0.001 * np.identity(4)  # 4x4
    a = np.array([[1, *(r_c - r_c_old)],
                  [0, 1, 0],
                  [0, 0, 1]])  # 3x3
    h = np.array([
        0,
        *(hessian @ (r_c - r_c_old))  # 2x2 . 2x1 = 2x1
    ])  # 3x1
    print(r - r_c)
    hc = np.array([hessian[0, 0], hessian[1, 0], hessian[0, 1], hessian[1, 1]])  # 4x1
    c = np.hstack((np.ones((numSensors, 1)), r - r_c))  # 4x3
    d = 0.5 * np.vstack([np.kron(pt - r_c, pt - r_c) for pt in r])  # 4x4

    s_e = a @ s + h  # 3x1
    p_e = a @ p @ a.T + m  # 3x3 @ 3x1 @ 3x3 = 3x3

    # c @ p_e @ c.T = 4x3 @ 3x3 @ 3x4 = 4x4
    # d @ u @ d.T = 4x4 @ 4x4 @ 4x4 = 4x4
    # p_e @ c.T @ inv... = 3x3 @ 3x4 @ 4x4 = 3x4

    K = p_e @ c.T @ np.linalg.inv((c @ p_e @ c.T) + (d @ u @ d.T) + R)  # 3x4

    # c @ s_e = 4x3 @ 3x1 = 4x1
    # d @ hc = 4x4 @ 4x1 = 4x1
    # K @ ... = 3x4 @ 4x1 = 3x1
    s = s_e + K @ (z_r - (c @ s_e) - (d @ hc))  # 3x1

    # d @ u @ d.T = 4x4 @ 4x4 @ 4x4 = 4x4
    # c.T @ .. @ c = 3x4 @ 4x4 @ 4x3 = 3x3
    p = np.linalg.inv(np.linalg.inv(p_e) + c.T @ np.linalg.inv(d @ u @ d.T + R) @ c)  # 3x3

    z_c = s[0]
    dz = s[1:]
    return z_c, dz, p


r_c_old = r_c
dz = dz_f(r_c[0], r_c[1])
z_c = f(r_c[0], r_c[1])

hessian = np.array([[2, 0], [0, 0.5]])
velocity_c = 1

p = np.zeros((3, 3))
x_2 = np.array([1, 0])
y_2 = np.array([0, 1])
r_obs = np.array([[-5.278, -2.011],
                  [4.021, 1.95]])
r_c_plot = []

for i in range(step):
    z_r = np.array([f(*pt) for pt in r])
    z_c, dz, p = kalmanFilter(z_c, dz, r, z_r, r_c, r_c_old, p, hessian, numSensors)
    # z_c : 1x1, dz : 2x1, p : 3x3
    hessian = np.array([[2, 0], [2, 0]]) * np.random.rand(1)
    r_c_old = r_c

    # New motion control
    y_1 = dz / np.linalg.norm(dz)
    x_1 = np.array([[cos(pi / 2), -sin(pi / 2)],
                    [sin(pi / 2), cos(pi / 2)]]) @ y_1

    if i == 0:
        x_2 = x_1
        y_2 = y_1

    theta = atan2(x_2[1], x_2[0]) - atan2(x_1[1], x_1[0])

    kappa_1 = (x_1.T @ hessian @ x_1) / np.linalg.norm(dz)
    kappa_2 = (x_1.T @ hessian @ y_1) / np.linalg.norm(dz)

    f_z = mu_f * (1 - z_desired / z_c) ** 2
    f_rep = np.sum([3 * log(np.linalg.norm(r_c - obs)) / 15 for obs in r_obs])
    f_rep = 0  ##

    u_c = kappa_1 * cos(theta) + kappa_2 * sin(theta) - (2 * f_z * np.linalg.norm(dz) * cos(theta / 2) ** 2) + K4 * sin(
        theta / 2) + f_rep
    x_2 = x_2 + dt * u_c * y_2
    y_2 = np.array([[cos(-pi / 2), -sin(-pi / 2)],
                    [sin(-pi / 2), cos(-pi / 2)]]) @ x_2
    r_c = r_c + dt * x_2

    # Formation Control
    e_1 = r[1] - r[0]
    e_1 = e_1 / np.linalg.norm(e_1)
    e_2 = r[2] - r[3]
    e_2 = e_2 / np.linalg.norm(e_2)

    q_0 = np.array([
        [0, 0],
        (a / sqrt(2)) * e_1,
        (b / sqrt(2)) * e_2,
        [0, 0]
    ])

    dq[1:] = dq[1:] + dt * u_r[1:]
    u_r[1:] = -K2 * (q[1:] - q_0[1:]) - K3 * dq[1:]

    vel_q[1:] = vel_q[1:] + dt * u_r[1:]
    q[1:] = q[1:] + dt * vel_q[1:]

    q_N = np.append([r_c], q[1:], axis=0)

    r = phi_inv @ q_N

    r_plot.append(r)
    r_c_plot.append(r_c)



# plt.contour(x, y, z, [80])



# plt.xlabel('x')
# plt.ylabel('y')
# plt.plot([r[0,0], r[1,0]], [r[0,1], r[1,1]], 'yo-')
# plt.plot([r[2,0], r[3,0]], [r[2,1], r[3,1]], 'go-')
# plt.plot(*zip(*r_c_plot), 'b')
# plt.show()

